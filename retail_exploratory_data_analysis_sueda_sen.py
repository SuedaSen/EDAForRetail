# -*- coding: utf-8 -*-
"""Retail Exploratory Data Analysis - Sueda Sen.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1F2XSNkEr-NAL7z39lSJnxFdIaP4eM2g_

# <font color='red'>Exploratory Data Analysis (EDA) </font>

> *EDA is applied to investigate the data and summarize the key insights. It will give you the basic understanding of your data, it's distribution, null values and much more.Exploratory data analysis (EDA) is used by data scientists to analyze and investigate data sets and summarize their main characteristics, often employing data visualization methods.*



---

# <font color='green'> Import Libraries </font>
"""

import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd

import warnings
warnings.filterwarnings('ignore')

"""**"ignore"** never print matching warnings.

---

# <font color='purple'> Reading The Data </font>
"""

dataFrame=pd.read_csv("/content/SupermarketRetailDataset.csv")

dataFrame.head()

"""The **head()** function is used to get the first n rows.

This function returns the first n rows for the object based on position.
"""

dataFrame.shape

"""The **shape of a DataFrame** is a tuple of array dimensions that tells the number of rows and columns of a given DataFrame"""

dataFrame.describe()

"""The **describe()** method returns description of the data in the DataFrame. This is summary actually.

If the DataFrame contains numerical data, the description contains these information for each column
"""

dataFrame.isnull().sum()

"""**isnull().sum()**returns the number of missing values in the dataset."""

dataFrame.info()

"""The **info() method** prints information about the DataFrame. The information contains the number of columns, column labels, column data types, memory usage, range index, and the number of cells in each column (non-null values). Note: the info() method actually prints the info."""

dataFrame.columns

"""---

# <font color='pink'>  Dropping Unwanted Columns </font>
"""

dataFrame.duplicated().sum()

"""The **duplicated()** method returns a Series with True and False values (Boolean) that describe which rows in the DataFrame are duplicated and not. We are finding their sum."""

dataFrame.nunique()

"""The **nunique()** method returns the number of unique values for *each column*. By specifying the column axis *( axis='columns' ), the nunique() method searches column-wise and returns the number of unique values for each row.*

---

*dataFrame.duplicated().sum()* returns us 17. So, there are 17 duplicate entries and *let us drop them*
"""

dataFrame.drop_duplicates(subset=None,keep='first',inplace=True)

"""DataFrame.drop_duplicates(subset=None, *, keep='first', inplace=False, ignore_index=False)[source]
Return DataFrame with duplicate rows removed.
Considering certain columns is optional. Indexes, including time indexes are ignored.

subsetcolumn label or sequence of labels, optional

    Only consider certain columns for identifying duplicates, by default use all of the columns.


keep{‘first’, ‘last’, False}, default ‘first’

    Determines which duplicates (if any) to keep. 
    - first : 
    Drop duplicates except for the first occurrence. 

    inplacebool, default False

    Whether to modify the DataFrame rather than creating a new one.

"""

dataFrame.drop_duplicates(inplace= True)

"""*Return DataFrame with duplicate rows removed.*"""

dataFrame.duplicated().sum()

"""We prove that remove the duplicate rows."""

dataFrame.drop(["Postal Code"], axis=1,inplace= True)

"""Dropping unwanted colums. **drop.inplace=True means** the operation would work on the **original object**. axis=1 means we are dropping the column, not the row.

In pandas **axis = 0 refers to** horizontal axis or **rows** and **axis = 1** refers to vertical axis or **columns**
"""

dataFrame.info()

dataFrame.columns

"""After drop Postal Code column, as you can see there is no Poscal Code column anymore."""

dataFrame.info()

"""---

# <font color='magenta'>  Correlation Between the Data  </font>

> *A correlation is a statistical measure of the relationship between two variables. The measure is best used in variables that demonstrate a linear relationship between each other. The fit of the data can be visually represented in a scatterplot.*
"""

corr = dataFrame.corr()

"""Pandas **dataFrame.corr()** is used to find the *pairwise correlation of all columns in the Pandas Dataframe in Python.* Any *NaN values are automatically excluded.* Any non-numeric data type or columns in the Dataframe, it is ignored."""

sns.heatmap(corr,annot=True,cmap='Reds')

"""**annot: If True**, *write the data value in each cell.* **cmap** is *colormap*

"""

sns.heatmap(corr,annot=False,cmap='Reds')

"""**annot: If False**, *dont write the data value in each cell.*"""

sns.heatmap(dataFrame.corr(), annot=True)

"""If we dont give cmap value, this is the default version

---
"""

sns.pairplot(dataFrame, hue = 'Ship Mode')

"""Plot pairwise relationships in a dataset.
seaborn.pairplot() :

> To plot multiple pairwise bivariate distributions in a dataset, you can use the .pairplot() function.

> The diagonal plots are the univariate plots, and this displays the relationship for the (n, 2) combination of variables in a DataFrame as a matrix of plots.

"""

dataFrame['Ship Mode'].value_counts()

sns.countplot(x=dataFrame['Ship Mode'])

"""From the above plot we can conclude that Standard Class has highest number of Ship Mode."""

dataFrame.columns

sns.pairplot(dataFrame, hue = 'Category')

dataFrame['Category'].value_counts()

sns.countplot(x=dataFrame['Category'])

"""From the above plot we can conclude that Office Supplies Category has highest number of sales."""

sns.pairplot(dataFrame,hue = 'Segment')

dataFrame['Segment'].value_counts()

sns.countplot(x=dataFrame['Segment'])

sns.countplot(x = 'Segment',data = dataFrame, palette = 'rainbow')

"""Show the counts of observations in each categorical bin using bars."""

sns.histplot(x = 'Segment',data = dataFrame)

"""From the above plot we can conclude that Consumer has highest number of Segment."""

dataFrame["Sub-Category"].value_counts()

plt.figure(figsize=(15,15))
plt.pie(dataFrame["Sub-Category"].value_counts(), labels= dataFrame["Sub-Category"].value_counts().index, autopct ="%2f")
plt.show()

"""Here, Sub-Category with highest sale is Binder, followed by Paper and Furnishings as second and third respectively.


"""

plt.figure(figsize=(15,12))
dataFrame['Sub-Category'].value_counts().plot.pie(autopct=':)')
plt.show()

"""Maximum are from Binders, Paper, Furnishings, Phones, Storage, Art, Accessories and Minimum from Copiers, Machines, Suppliers"""

dataFrame['State'].value_counts()

plt.figure(figsize=(15,12))
sns.countplot(x='State',data=dataFrame,palette='rainbow',order=dataFrame['State'].value_counts().index) #rocket_r or rainbow used for palette 
#,order=dataFrame['State'].value_counts().index for order so add after rainbow
plt.xticks(rotation=90) #Get or set the current tick locations and labels of the x-axis.
plt.show()

"""Highest number of buyers are from California and New York"""

dataFrame.hist(figsize=(10,10),bins=50)
plt.show()

"""A histogram is a representation of the distribution of data. This function calls matplotlib.pyplot.hist(), on each series in the DataFrame, resulting in one histogram per column.

*bins* should be the number of bars you want to show in your histogram plot.

Most customers tends to buy quantity of 2 and 3
    Discount give maximum is 0 to 20 percent
"""

st_profit=dataFrame.groupby(["State"])["Profit"].sum().nlargest(20)

st_profit

plt.figure(figsize=(15,8))
st_profit.plot.bar()

st_profit.plot.line()

st_profit.plot.barh()

st_sales=dataFrame.groupby(["Category"])["Sales"].sum().nlargest(20)

st_sales

plt.figure(figsize=(12,4))
st_sales.plot.bar()

st_sales.plot.barh()

sns.lineplot(data=dataFrame, x="Discount", y= "Profit")

"""So we can see that when discount increases profit decreases"""

dataFrame.plot(kind="scatter",x="Sales",y="Profit", c="Discount", colormap="Set1",figsize=(12,12))

"""In this scatter plot we can clearly see that more sales does not mean more profit. It depends on discount as well. 
When Sales is high and there is low discount, the profit margin is higher.
"""

dataFrame.plot.scatter(x = 'Category', y = 'Sales', s = 'Sales', c = 'red');

"""

---

"""

data1= dataFrame.groupby("State")[["Sales","Profit"]].sum().sort_values(by="Sales", ascending=False)
data1[:].plot.bar(color = ["Green","Red"], figsize=(20,12))
plt.title("Profit-Loss and Sales across States")
plt.show()

"""California and New York generate more profit compared to the other states.

    High profit is for California, New york
    Loss is for Texas, Pennsylvania, Ohio

"""

plt.figure(figsize=(10,8))
dataFrame['Region'].value_counts().plot.pie(autopct = '%1.1f%%')
plt.show()

"""---

# <font color='brown'> Profit vs Discount  </font>
"""

fig,ax=plt.subplots(figsize=(20,8))
ax.scatter(dataFrame['Sales'],dataFrame['Profit'])
ax.set_xlabel('Sales')
ax.set_ylabel('Profit')
plt.show()

sns.lineplot(x='Discount',y='Profit',label='Profit',data=dataFrame)
plt.legend()
plt.show()

"""No correlation between profit and discount

"""

sns.heatmap(dataFrame.corr(), annot=True)

"""---

# <font color='maroon'>  Profit vs Quantity  </font>
"""

sns.lineplot(x='Quantity',y='Profit',label='Profit',data=dataFrame)
plt.legend()
plt.show()

"""A legend is an area describing the elements of the graph. In the matplotlib library, there’s a function called legend() which is used to Place a legend on the axes."""

dataFrame.groupby('Segment')[['Profit','Sales']].sum().plot.bar(color=['pink','blue'],figsize=(8,5))
plt.ylabel('Profit/Loss and sales')
plt.show()

"""Profit and sales are maximum in Consumer segment and minimum in Home Office segment

---
"""

plt.figure(figsize=(12,8))
plt.title('Segment wise Sales in each Region')
sns.barplot(x='Region',y='Sales',data=dataFrame,hue='Segment',order=dataFrame['Region'].value_counts().index,palette='rocket')
plt.xlabel('Region',fontsize=15)
plt.show()

"""Segment wise sales are almost same in every region

---
"""

dataFrame.groupby('Region')[['Profit','Sales']].sum().plot.bar(color=['blue','red'],figsize=(8,5))
plt.ylabel('Profit/Loss and sales')
plt.show()

"""Profit and sales are maximum in west region and minimum in south region

---
"""

dataFrame.groupby('Category')[['Profit','Sales']].sum().plot.bar(color=['yellow','purple'],alpha=0.9,figsize=(8,5))
plt.ylabel('Profit/Loss and sales')
plt.show()

"""Weak areas where you can work to make more profit?

    Technology and Office Supplies have high profit.
    Furniture have less profit

---
"""

ps = dataFrame.groupby('Sub-Category')[['Sales','Profit']].sum().sort_values(by='Sales',ascending=False)
ps[:].plot.bar(color=['red','lightblue'],figsize=(15,8))
plt.title('Profit/loss & Sales across states')
plt.xlabel('Sub-Category')
plt.ylabel('Profit/loss & Sales')
plt.show()

"""*   Phones sub-category have high sales.

*   Chairs have high sales but less profit compared to phones

*   Tables and Bookmarks sub-categories facing huge loss

---

# <font color='orange'>  Profit Loss and Sales Across Region  </font>
"""

data1= dataFrame.groupby("Region")[["Sales","Profit"]].sum().sort_values(by="Sales", ascending=False)
data1[:].plot.bar(color = ["Blue","Red"], figsize=(10,7))
plt.title("Profit-Loss and Sales across Region")
plt.show()

"""**Conclusion:**

    The western region generates highest profit.
    California, NewYork and Washington generates the most sales compared to the other places.
    The central region generates lowest profit.
    Texas, Pennsylvenia, Florida, Illinois, Ohio and some other states are generating loss with high sale. So we need to give some attention towards them.

Therefore, we have to work more on California and New York. Increase the sales in these states by reducing sales in states like Texas, Florida, Ohio. By decreasing the discount rates in Central region we can increase the profit. Finally we should increase the sale of Office Supplies category as they contribute more.

"""